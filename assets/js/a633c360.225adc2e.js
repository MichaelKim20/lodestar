"use strict";(self.webpackChunk_lodestar_docs=self.webpackChunk_lodestar_docs||[]).push([[692],{4365:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>i,default:()=>h,frontMatter:()=>s,metadata:()=>a,toc:()=>d});var o=t(4848),l=t(8453);const s={title:"Core Dumps"},i="Core Dump Analysis",a={id:"contribution/tools/core-dumps",title:"Core Dumps",description:"Core dump analysis is some ninja level stuff. Once you get the hang of it you will feel like you have super powers. It will up your game to a whole new level because you will be able to debug issues that seemed impossible before. Post-crash analysis is a very powerful tool to have in your tool belt. A core dump has all of the objects in memory as well as all of the stack frame information at the exact moment the dump was taken, usually when a hard crash occurs.",source:"@site/pages/contribution/tools/core-dumps.md",sourceDirName:"contribution/tools",slug:"/contribution/tools/core-dumps",permalink:"/lodestar/contribution/tools/core-dumps",draft:!1,unlisted:!1,editUrl:"https://github.com/ChainSafe/lodestar/tree/unstable/docs/pages/contribution/tools/core-dumps.md",tags:[],version:"current",frontMatter:{title:"Core Dumps"},sidebar:"tutorialSidebar",previous:{title:"Heap Dumps",permalink:"/lodestar/contribution/tools/heap-dumps"},next:{title:"Testing",permalink:"/lodestar/contribution/testing/"}},r={},d=[{value:"Installing <code>llnode</code>",id:"installing-llnode",level:2},{value:"Collecting a core dump",id:"collecting-a-core-dump",level:2},{value:"Analyzing a core dump",id:"analyzing-a-core-dump",level:2}];function c(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,l.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"core-dump-analysis",children:"Core Dump Analysis"}),"\n",(0,o.jsx)(n.p,{children:"Core dump analysis is some ninja level stuff. Once you get the hang of it you will feel like you have super powers. It will up your game to a whole new level because you will be able to debug issues that seemed impossible before. Post-crash analysis is a very powerful tool to have in your tool belt. A core dump has all of the objects in memory as well as all of the stack frame information at the exact moment the dump was taken, usually when a hard crash occurs."}),"\n",(0,o.jsxs)(n.p,{children:["It is important to note that debug symbols will greatly aid you in your debugging for issues related to native code like ",(0,o.jsx)(n.code,{children:"C/C++"}),". When compiled languages are optimized the compiler will often strip out identifiers and all that will be remaining are mangled symbols and addresses. Compiling with debug symbols will leave all of the identifiers, file names and line numbers in-tact."]}),"\n",(0,o.jsx)(n.p,{children:"While it is not always practical to be running code in a Debug version of node, if you run across a persistent issue it will be helpful to recreate it on a debug build and to use that for analysis."}),"\n",(0,o.jsx)(n.p,{children:"It is important to note that the EXACT binary that was running when the dump was created MUST be loaded when doing analysis. There is a lot of information in the dump that is specific to the binary that was running (like function offsets, etc). If you load a different binary you will get a lot of errors and the analysis will not be useful (if it loads at all)."}),"\n",(0,o.jsx)(n.p,{children:"It is also a nice-to-know that you can create the dump on linux, using a linux compiled version of node, and then read it on a mac. All that is needed is to download the node binary and dump file to the mac. It is possible to load them into a mac compiled version of llnode and all will work as expected. Its just the meta in the linux binary that is needed for analysis, it doesn't actually run the code."}),"\n",(0,o.jsxs)(n.h2,{id:"installing-llnode",children:["Installing ",(0,o.jsx)(n.code,{children:"llnode"})]}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.code,{children:"llnode"})," is a Node.js plugin for the ",(0,o.jsx)(n.a,{href:"https://lldb.llvm.org/",children:"LLDB"})," debugger. It is the officially sanctioned tool from Node and powerful way to do postmortem analysis of Node.js processes. The process for install is pretty straight-forward unless you have an M1 mac. XCode ships with an instance of ",(0,o.jsx)(n.code,{children:"lldb"})," and installing ",(0,o.jsx)(n.code,{children:"llnode"})," is as simple as running ",(0,o.jsx)(n.code,{children:"npm install -g llnode"}),"."]}),"\n",(0,o.jsxs)(n.p,{children:["On an M1 mac the install will work fine but the plugin will crash at load time. See ",(0,o.jsx)(n.a,{href:"https://github.com/nodejs/llnode/issues/430#issuecomment-1844628224",children:"this issue"})," for updates. The workaround is to install ",(0,o.jsx)(n.code,{children:"lldb"})," via homebrew."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sh",children:"# should only be necessary on M1 macs at time of writing\n$ brew install llvm\n$ echo 'export PATH=\"/opt/homebrew/opt/llvm/bin:$PATH\"' >> ~/.zshrc\n$ # note that its before recopying PATH to make sure it resolves\n$ zsh ~/.zshrc\n$ which llvm-config\n/opt/homebrew/opt/llvm/bin/llvm-config # if this is not what comes up restart the shell\n$ npm install -g llnode\n$ llnode\n(lldb) plugin load '/Users/ninja_user/.nvm/versions/node/v22.1.0/lib/node_modules/llnode/llnode.dylib'\n(lldb) settings set prompt '(llnode) '\n(llnode)\n"})}),"\n",(0,o.jsx)(n.h2,{id:"collecting-a-core-dump",children:"Collecting a core dump"}),"\n",(0,o.jsx)(n.p,{children:"Before a core dump can be created the system must be enabled."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sh",children:"ulimit -c unlimited\n"})}),"\n",(0,o.jsx)(n.p,{children:"This is a critical step. If that command is not run the core will not be dumped to disk."}),"\n",(0,o.jsxs)(n.p,{children:["Core dumps are normally created by the kernel when certain process signals are encountered. ",(0,o.jsx)(n.code,{children:"SIGSEGV"})," is the most common signal that will cause a dump and its sent by the kernel to the process when a segfault occurs. ",(0,o.jsx)(n.code,{children:"SIGSEGV"})," is not the only signal that works and you can see the full list ",(0,o.jsx)(n.a,{href:"https://man7.org/linux/man-pages/man7/signal.7.html",children:"here"}),' under the "Standard Signals" section (all the ones that say "Core" in the "Action" column).']}),"\n",(0,o.jsxs)(n.p,{children:["If you want to create a dump on demand you can use the ",(0,o.jsx)(n.code,{children:"gcore"})," command on linux. This will create a dump of the process without killing it. If you don't mind termination you can also use ",(0,o.jsx)(n.code,{children:"kill -SIGSEGV <pid>"})," to send the a dump signal to the process."]}),"\n",(0,o.jsx)(n.h2,{id:"analyzing-a-core-dump",children:"Analyzing a core dump"}),"\n",(0,o.jsxs)(n.p,{children:["Once you collect the core dump you can load it into ",(0,o.jsx)(n.code,{children:"llnode"})," for debugging."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-sh",children:"# remember that the node binary must be the exact same one that was running when the core was created\n$ llnode -f /path/to/node_debug -c /Users/ninja_user/coredumps/node.coredump\n(lldb) target create \"node_debug\" --core \"node.coredump\"\nCore file '/Users/ninja_user/coredumps/node.coredump' (x86_64) was loaded.\n(lldb) plugin load '/Users/ninja_user/.nvm/versions/node/v22.1.0/lib/node_modules/llnode/llnode.dylib'\n(lldb) settings set prompt '(llnode) '\n(llnode)\n"})}),"\n",(0,o.jsx)(n.p,{children:"Once the dump is loaded the first few steps will be to figure out what types of objects were in memory and what was the processor working on when the crash occurred. Lets start with the stack trace."}),"\n",(0,o.jsxs)(n.p,{children:["There are two distinct commands for pulling the stack because node is both a native runtime and a virtual machine. The ",(0,o.jsx)(n.code,{children:"bt"}),", back trace, command will pull the native stack frames and the ",(0,o.jsx)(n.code,{children:"v8 bt"})," command will use the ",(0,o.jsx)(n.code,{children:"llnode"})," plugin to pull the JavaScript stack frames. Newer versions of ",(0,o.jsx)(n.code,{children:"llnode"})," will automatically pull the JavaScript stack frames when the ",(0,o.jsx)(n.code,{children:"bt"})," command is run but it is still good to know the difference. It is also possible to add the ",(0,o.jsx)(n.code,{children:"all"})," verb to the ",(0,o.jsx)(n.code,{children:"bt"})," command and it will pull the back trace for all threads."]}),"\n",(0,o.jsxs)(n.p,{children:["To start looking through memory there are two commands that are helpful. The ",(0,o.jsx)(n.code,{children:"v8 findjsobjects"})," command will list all of the JavaScript objects in memory. The ",(0,o.jsx)(n.code,{children:"v8 findjsinstances"})," command will list all of the instances of a particular JavaScript object."]})]})}function h(e={}){const{wrapper:n}={...(0,l.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>a});var o=t(6540);const l={},s=o.createContext(l);function i(e){const n=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:i(e.components),o.createElement(s.Provider,{value:n},e.children)}}}]);